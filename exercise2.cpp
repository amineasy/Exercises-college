/*
ایده‌ی حل به این صورته که همه‌ی کارها حتماً انجام می‌شن،
یا توسط داوطلب‌ها یا توسط خود زهرا.

اول فرض می‌کنیم همه‌ی وظیفه‌ها رو داوطلب‌ها انجام دادن،
پس خوشحالی اولیه برابر با جمع همه‌ی b_i ها می‌شه.

اگر زهرا یک کار رو خودش انجام بده، به جای b_i مقدار a_i
خوشحال می‌شه، یعنی به اندازه‌ی (a_i - b_i) خوشحالی بیشتری
نسبت به حالت داوطلب به دست میاره.

از اونجایی که زهرا بیشتر از m کار نمی‌تونه انجام بده،
باید اون m کاری رو انتخاب کنیم که بیشترین سود اضافه
(a_i - b_i) رو دارن.

برای همین اختلاف a_i و b_i رو برای همه‌ی وظیفه‌ها حساب
می‌کنیم، مرتبشون می‌کنیم و m تای بزرگ‌تر رو به خوشحالی
اولیه اضافه می‌کنیم. اینطوری بیشترین خوشحالی ممکن به دست میاد.
*/











#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    // n تعداد وظیفه‌هاست
    // m حداکثر تعداد وظیفه‌ایه که زهرا می‌تونه خودش انجام بده

    long long base = 0;
    // base خوشحالی اولیه است، وقتی فرض کنیم همه‌ی کارها را داوطلب‌ها انجام می‌دهند

    vector<int> gain;
    gain.reserve(n);
    // gain برای نگه‌داشتن سود اضافه‌ی هر وظیفه است
    // یعنی اینکه اگر زهرا خودش انجام بده، چقدر خوشحال‌تر می‌شود

    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        // a خوشحالی وقتی خود زهرا انجام دهد
        // b خوشحالی وقتی داوطلب انجام دهد

        base += b;
        // فعلاً فرض می‌کنیم این وظیفه را داوطلب انجام داده
        // پس b را به خوشحالی پایه اضافه می‌کنیم

        gain.push_back(a - b);
        // اختلاف a و b را ذخیره می‌کنیم
        // این مقدار سود اضافه‌ای است که اگر زهرا این کار را خودش انجام دهد
    }

    sort(gain.begin(), gain.end(), greater<int>());
    // سودها را نزولی مرتب می‌کنیم
    // چون می‌خواهیم بیشترین سودها را اول انتخاب کنیم

    for (int i = 0; i < m && i < n; i++) {
        base += gain[i];
        // زهرا حداکثر m کار می‌تواند انجام دهد
        // پس m تا از بیشترین سودها را به خوشحالی پایه اضافه می‌کنیم
    }

    cout << base << '\n';
    // در نهایت بیشترین مقدار خوشحالی را چاپ می‌کنیم

    return 0;
}
